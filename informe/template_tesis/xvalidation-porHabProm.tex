% Juntar por cada hablante sus audios en una muestra sola promediando sus atributos
\subsection{Promediando los atributos de cada hablante}

Vamos a armarnos un modelo de test similar al anterior pero donde su conjunto de datos no sea desequilibrado con respecto a la cantidad de instancias de cada clase. Nunca es bueno descartar datos pero debemos saber si utilizando los atributos que definidos podemos realizar una mejor clasificación.

Tomaremos 8 hablantes de Buenos Aires y de 8 Córdoba. De esta forma, el conjunto de datos está equilibrado en cantidad. La elección de cada uno de estos hablantes fue al azar. Como el esquema anterior, vamos a tener un fold por cada hablante. En la Tabla \ref{cv-porHabProm} vemos este esquema.

\begin{center}
	\mycirc[blue] Hablante para train \mycirc[red] Hablante para test
\end{center}

\begin{table}[H]
	\centering
	\begin{tabular}{cccccccccccc}
		& \multicolumn{11}{c}{\textit{Número de hablante}} \\
		& 1 & 2 & 3 & 4 & 5 & 6 & 7 & ... & 14 & 15 & 16 \\
		\hline \\
		Fold 1 &\mycirc[red] & \mycirc[blue] & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue] & ... & \mycirc[blue] & \mycirc[blue] & \mycirc[blue]  \\
		
		Fold 2 &\mycirc[blue] & \mycirc[red] & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue] & ... & \mycirc[blue] & \mycirc[blue] & \mycirc[blue]  \\
		
		Fold 3 &\mycirc[blue] & \mycirc[blue] & \mycirc[red]  & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue] & ... & \mycirc[blue] & \mycirc[blue] & \mycirc[blue]  \\
		
		\multicolumn{11}{c}{\textit{...}}	\\
		
		Fold 16 &\mycirc[blue] & \mycirc[blue] & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue]  & \mycirc[blue] & ... & \mycirc[blue] & \mycirc[blue] & \mycirc[red]   \\
		
	\end{tabular}
	\caption{Esquema de cross-validation}
	\label{cv-porHabProm}
\end{table}

Otro problema que surgió del anterior cross-validation es la masiva cantidad de valores desconocidos. Esto hace que clasificadores como C4.5 devuelvan resultados muy pobre. 

Para evitar esto realizamos lo siguiente: juntamos las grabaciones de cada hablante calculando su promedio para cada atributo. Veamos en la tabla \ref{datos_orig} un ejemplo de datos extraídos para entender la idea. 

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|ccccc|}
		\hline
		\multicolumn{2}{|l|}{Atributos} & A1 & A2 & A3 & ... & AN \\
		\hline 
		\textbf{Hablante 1} & \textbf{Audio1} & 1 & ? & 2 & & 2\\
		& \textbf{Audio2} & ? & ? & 1 & ... & ? \\
		& \textbf{Audio3} & 2 & ? & 3 & & ? \\
		\hline
		\textbf{Hablante 2} & \textbf{Audio1} & 1 & ? & ? & ... & ? \\
		& \textbf{Audio2} & 1 & 2 & ? & & ? \\
		\hline
	\end{tabular}
	\caption{Datos originales}
	\label{datos_orig}
\end{table}

Para cada hablante vamos a juntar sus audios realizando el promedio de cada atributo. Por ejemplo: el Hablante 1 grabó 3 audios donde cada uno posee distintos atributos. Juntamos todos esos audios en uno promediando sus atributos: El Audio1 y Audio3 poseen el atributo A1 con valor 1 y 2 respectivamente. Entonces en la tabla \ref{datos_comb} tendremos Audio1 con A1 definido como el promedio de estos valores: $1 + 2 = 1,5$. Ninguno de los audios grabados originalmente por Hablante 1 definió A2, entonces en este caso no vamos a poder definir ningún valor y va a quedar como valor desconocido. 

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|ccccc|}
		\hline
		\multicolumn{2}{|l|}{Atributos} & A1 & A2 & A3 & ... & AN \\
		\hline 
		\textbf{Hablante 1} & \textbf{Audio1} & \textbf{1.5} & \textbf{?} & \textbf{1.667} & ... & \textbf{2}\\
		\hline
		\textbf{Hablante 2} & \textbf{Audio1} & \textbf{1} & \textbf{2} & \textbf{?} & ... & \textbf{?} \\
		\hline
	\end{tabular}
	\caption{Atributos modificados}
	\label{datos_comb}
\end{table}

Resumiendo por cada hablante se define una fila de atributos. Esto minimizaría la cantidad de valores desconocidos por cada grabación.

\subsection{Resultados}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|c|c|c|c|c|}
		\hline
		\textbf{}  & \textbf{ZeroR} & \textbf{JRip} & \textbf{J48} & \textbf{Function SMO} & \textbf{NaiveBayes} \\ \hline
		\textbf{Promedio} & 53.33 & 60 & 60 & 93.33 & 80  \\ \hline
	\end{tabular}
	\caption{Clasificación correcta en porcentaje}
	\label{class_corr_en_pct}
\end{table}

\subsubsection{Wilcoxon y Test t de Student}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|c|c|c|c|c|}
		\hline
		\textbf{}  & \textbf{Student Test} & \textbf{Wilcoxon Test} \\ \hline
		\textbf{ZeroR y JRip}  &  &  \\ \hline
		\textbf{ZeroR y J48}  &  &  \\ \hline
		\textbf{ZeroR y NaiveBayes}  &  &  \\ \hline
		\textbf{ZeroR y Function SMO}  &  & \\ \hline
	\end{tabular}
	\caption{Resultados de cada test representado en p-valor}
	\label{res_tests_wilcoxon_student}
\end{table}

\subsection{Características del modelo de test}

Este modelo de test dió muy buenos resultados. El clasificador ZeroR tuvo una performance esperada de alrededor del 50 \% mientras que el clasificador C 4.5 pudo armar árboles mejores. 

Sin embargo, la forma que evitamos los valores desconocidos no es la mejor. El resultado de un fold para un determinado clasificador es 0\% o 100\%. Esto sucede porque es sólo una instancia la que representa. 

Esto también se ve reflejado en las matrices de confusión de cada fold. Cada una de ellas son de la forma: 

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		Buenos Aires & Córdoba & \\ \hline
		1 & 0 & Buenos Aires\\ \hline
		0 & 0 & Córdoba\\ \hline
	\end{tabular}
\end{table}

Donde siempre se encuentra sólo una instancia.

